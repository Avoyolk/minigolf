<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro Mini Golf - Jesse's Tour</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e272e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            touch-action: none; 
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 900px;
            aspect-ratio: 16/9;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            display: block;
            background: #4cd137; /* Fallback */
        }

        /* Overlay UI for Name and Level */
        .ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
            font-weight: bold;
            font-size: 18px;
            z-index: 10;
        }

        .player-badge {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .avatar {
            width: 24px;
            height: 24px;
            background: #f1c40f;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        #level-indicator {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* Message Overlay (Win/Next Level) */
        #message-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            border-radius: 12px;
            z-index: 20;
            backdrop-filter: blur(5px);
        }
        
        #message-title { font-size: 3rem; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px; color: #f1c40f; }
        #message-sub { font-size: 1.2rem; margin-bottom: 20px; color: #dfe6e9; }
        
        button {
            background: linear-gradient(to bottom, #f1c40f, #f39c12);
            border: none;
            padding: 12px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

    </style>
</head>
<body>

    <div id="gameContainer">
        <div class="ui-layer">
            <div class="player-badge">
                <div class="avatar"></div>
                <span>JESSE</span>
            </div>
            <div id="level-indicator">LEVEL 1 / 10</div>
        </div>

        <div id="message-overlay">
            <div id="message-title">HOLE IN ONE!</div>
            <div id="message-sub">Strokes: 1</div>
            <button id="nextBtn">NEXT LEVEL</button>
        </div>

        <canvas id="gameCanvas" width="900" height="506"></canvas> </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const levelText = document.getElementById('level-indicator');
    const msgOverlay = document.getElementById('message-overlay');
    const msgTitle = document.getElementById('message-title');
    const msgSub = document.getElementById('message-sub');
    const nextBtn = document.getElementById('nextBtn');

    // --- Asset Generation (Procedural Textures) ---
    // Creates a grass pattern
    const grassPattern = (() => {
        const pCanvas = document.createElement('canvas');
        pCanvas.width = 64; pCanvas.height = 64;
        const pCtx = pCanvas.getContext('2d');
        pCtx.fillStyle = '#44bd32'; // Base Green
        pCtx.fillRect(0, 0, 64, 64);
        // Noise
        for(let i=0; i<400; i++) {
            pCtx.fillStyle = Math.random() > 0.5 ? '#4cd137' : '#43a047';
            pCtx.globalAlpha = 0.3;
            pCtx.beginPath();
            pCtx.arc(Math.random()*64, Math.random()*64, 1.5, 0, Math.PI*2);
            pCtx.fill();
        }
        return ctx.createPattern(pCanvas, 'repeat');
    })();

    // --- Game State ---
    let currentLevelIdx = 0;
    let strokes = 0;
    let gameState = 'PLAYING'; // PLAYING, ANIMATING, STOPPED
    
    // Physics State
    let isDragging = false;
    let dragStart = {x:0, y:0};
    let dragCurrent = {x:0, y:0};
    const FRICTION = 0.97;
    const POWER_SCALE = 0.18;
    const MAX_POWER = 22;
    const STOP_THRESHOLD = 0.15;

    // Entities
    let ball = { x: 100, y: 250, r: 9, vx: 0, vy: 0 };
    let hole = { x: 800, y: 250, r: 14 };
    let walls = [];

    // --- Level Design (10 Levels) ---
    // W = Width (900), H = Height (506)
    // Coords are approximate based on 900x506 canvas
    const levels = [
        // Level 1: The Straight Shot
        {
            ball: {x: 100, y: 253},
            hole: {x: 800, y: 253},
            walls: [
                {x: 450, y: 150, w: 20, h: 206}, // Middle blocker
            ]
        },
        // Level 2: The Tunnel
        {
            ball: {x: 80, y: 253},
            hole: {x: 820, y: 253},
            walls: [
                {x: 300, y: 0, w: 30, h: 200},
                {x: 300, y: 306, w: 30, h: 200},
                {x: 600, y: 0, w: 30, h: 200},
                {x: 600, y: 306, w: 30, h: 200}
            ]
        },
        // Level 3: The Zig Zag
        {
            ball: {x: 50, y: 50},
            hole: {x: 850, y: 450},
            walls: [
                {x: 200, y: 0, w: 20, h: 350},
                {x: 500, y: 156, w: 20, h: 350},
                {x: 700, y: 0, w: 20, h: 250}
            ]
        },
        // Level 4: The Box
        {
            ball: {x: 450, y: 450},
            hole: {x: 450, y: 50},
            walls: [
                {x: 250, y: 150, w: 400, h: 20}, // Top of box
                {x: 250, y: 350, w: 400, h: 20}, // Bottom of box
                {x: 250, y: 150, w: 20, h: 220}, // Left
                {x: 630, y: 150, w: 20, h: 140}  // Right (with gap)
            ]
        },
        // Level 5: Pillars
        {
            ball: {x: 50, y: 253},
            hole: {x: 850, y: 253},
            walls: [
                {x: 200, y: 100, w: 40, h: 40}, {x: 200, y: 366, w: 40, h: 40},
                {x: 400, y: 233, w: 40, h: 40},
                {x: 600, y: 100, w: 40, h: 40}, {x: 600, y: 366, w: 40, h: 40}
            ]
        },
        // Level 6: The Narrow Pass
        {
            ball: {x: 50, y: 253},
            hole: {x: 850, y: 253},
            walls: [
                {x: 300, y: 0, w: 300, h: 210},
                {x: 300, y: 296, w: 300, h: 210}
            ]
        },
        // Level 7: Corners
        {
            ball: {x: 50, y: 50},
            hole: {x: 50, y: 450},
            walls: [
                {x: 150, y: 0, w: 20, h: 400},
                {x: 300, y: 100, w: 20, h: 406},
                {x: 450, y: 0, w: 20, h: 400},
                {x: 600, y: 100, w: 20, h: 406}
            ]
        },
        // Level 8: The Fork
        {
            ball: {x: 50, y: 253},
            hole: {x: 850, y: 253},
            walls: [
                {x: 300, y: 200, w: 300, h: 106}, // Center block forcing split
            ]
        },
        // Level 9: The Cage
        {
            ball: {x: 450, y: 253},
            hole: {x: 850, y: 253},
            walls: [
                {x: 400, y: 200, w: 100, h: 10}, // Box around player
                {x: 400, y: 300, w: 100, h: 10},
                {x: 400, y: 200, w: 10, h: 110},
                // Opening on right
            ]
        },
        // Level 10: Grand Finale
        {
            ball: {x: 50, y: 50},
            hole: {x: 850, y: 450},
            walls: [
                {x: 100, y: 150, w: 700, h: 20},
                {x: 100, y: 330, w: 700, h: 20},
                {x: 400, y: 150, w: 20, h: 200}
            ]
        }
    ];

    // --- Init ---
    function loadLevel(index) {
        if (index >= levels.length) {
            msgTitle.innerText = "TOUR COMPLETE!";
            msgSub.innerText = "Jesse is the Champion!";
            nextBtn.innerText = "REPLAY TOUR";
            nextBtn.onclick = () => { currentLevelIdx = 0; loadLevel(0); };
            msgOverlay.style.display = 'flex';
            return;
        }

        const data = levels[index];
        ball.x = data.ball.x;
        ball.y = data.ball.y;
        ball.vx = 0; ball.vy = 0;
        hole.x = data.hole.x;
        hole.y = data.hole.y;
        walls = data.walls.map(w => ({...w})); // Deep copy
        
        strokes = 0;
        gameState = 'PLAYING';
        levelText.innerText = `LEVEL ${index + 1} / 10`;
        msgOverlay.style.display = 'none';
    }

    // --- Input Logic (Mobile + Desktop) ---
    function getInputPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        let cx = e.clientX, cy = e.clientY;
        if (e.touches && e.touches.length > 0) {
            cx = e.touches[0].clientX;
            cy = e.touches[0].clientY;
        }
        return {
            x: (cx - rect.left) * scaleX,
            y: (cy - rect.top) * scaleY
        };
    }

    function onStart(e) {
        if (gameState !== 'PLAYING') return;
        // Only allow drag if ball is slow
        if (Math.abs(ball.vx) < STOP_THRESHOLD && Math.abs(ball.vy) < STOP_THRESHOLD) {
            isDragging = true;
            const pos = getInputPos(e);
            dragStart = pos;
            dragCurrent = pos;
        }
    }

    function onMove(e) {
        if (!isDragging) return;
        if(e.cancelable) e.preventDefault(); // Stop scroll
        dragCurrent = getInputPos(e);
    }

    function onEnd() {
        if (!isDragging) return;
        isDragging = false;
        
        let dx = dragStart.x - dragCurrent.x;
        let dy = dragStart.y - dragCurrent.y;
        
        // Power limit
        const rawLen = Math.sqrt(dx*dx + dy*dy);
        
        ball.vx = dx * POWER_SCALE;
        ball.vy = dy * POWER_SCALE;

        // Cap speed
        const speed = Math.sqrt(ball.vx**2 + ball.vy**2);
        if (speed > MAX_POWER) {
            const ratio = MAX_POWER / speed;
            ball.vx *= ratio;
            ball.vy *= ratio;
        }
        
        // Only count stroke if power was sufficient
        if (speed > 1) {
            strokes++;
        }
    }

    canvas.addEventListener('mousedown', onStart);
    canvas.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onEnd);
    canvas.addEventListener('touchstart', onStart, {passive: false});
    canvas.addEventListener('touchmove', onMove, {passive: false});
    window.addEventListener('touchend', onEnd);

    // --- Physics Engine ---
    function update() {
        if (gameState !== 'PLAYING') return;

        // Movement
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Friction
        ball.vx *= FRICTION;
        ball.vy *= FRICTION;

        // Stop
        if (Math.abs(ball.vx) < STOP_THRESHOLD) ball.vx = 0;
        if (Math.abs(ball.vy) < STOP_THRESHOLD) ball.vy = 0;

        // Canvas Bounds
        if (ball.x < ball.r) { ball.x = ball.r; ball.vx *= -0.9; }
        if (ball.x > canvas.width - ball.r) { ball.x = canvas.width - ball.r; ball.vx *= -0.9; }
        if (ball.y < ball.r) { ball.y = ball.r; ball.vy *= -0.9; }
        if (ball.y > canvas.height - ball.r) { ball.y = canvas.height - ball.r; ball.vy *= -0.9; }

        // Wall Collision
        walls.forEach(w => {
            let testX = ball.x;
            let testY = ball.y;

            if (ball.x < w.x) testX = w.x;
            else if (ball.x > w.x + w.w) testX = w.x + w.w;

            if (ball.y < w.y) testY = w.y;
            else if (ball.y > w.y + w.h) testY = w.y + w.h;

            let distX = ball.x - testX;
            let distY = ball.y - testY;
            let distance = Math.sqrt(distX*distX + distY*distY);

            if (distance <= ball.r) {
                // Collision happened
                // Resolve Velocity
                if (Math.abs(distX) > Math.abs(distY)) {
                    ball.vx *= -1;
                    // Push out
                    ball.x += (distX > 0) ? (ball.r - distance) : -(ball.r - distance);
                } else {
                    ball.vy *= -1;
                    ball.y += (distY > 0) ? (ball.r - distance) : -(ball.r - distance);
                }
            }
        });

        // Win Check
        let distHole = Math.sqrt((ball.x - hole.x)**2 + (ball.y - hole.y)**2);
        let speed = Math.sqrt(ball.vx**2 + ball.vy**2);
        
        if (distHole < hole.r * 0.8 && speed < 8) {
            // Snap to hole visual
            ball.x = hole.x;
            ball.y = hole.y;
            ball.vx = 0; ball.vy = 0;
            gameState = 'WON';
            
            // Show UI
            setTimeout(() => {
                msgTitle.innerText = "LEVEL CLEAR!";
                msgSub.innerText = `Strokes: ${strokes}`;
                nextBtn.innerText = "NEXT LEVEL >>";
                nextBtn.onclick = () => {
                    currentLevelIdx++;
                    loadLevel(currentLevelIdx);
                };
                msgOverlay.style.display = 'flex';
            }, 200);
        }
    }

    // --- Rendering (Visuals) ---
    function draw() {
        // 1. Background (Grass)
        ctx.fillStyle = grassPattern;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. Shadows for walls
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        walls.forEach(w => {
            ctx.fillRect(w.x + 5, w.y + 5, w.w, w.h);
        });

        // 3. Walls (Wood texture look)
        walls.forEach(w => {
            // Wood Base
            const grad = ctx.createLinearGradient(w.x, w.y, w.x + w.w, w.y + w.h);
            grad.addColorStop(0, '#8d6e63');
            grad.addColorStop(1, '#5d4037');
            ctx.fillStyle = grad;
            
            // Bevel/Border
            ctx.fillRect(w.x, w.y, w.w, w.h);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = 2;
            ctx.strokeRect(w.x, w.y, w.w, w.h);
            
            // Nail details
            ctx.fillStyle = '#3e2723';
            ctx.beginPath(); ctx.arc(w.x+5, w.y+5, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(w.x+w.w-5, w.y+w.h-5, 2, 0, Math.PI*2); ctx.fill();
        });

        // 4. Hole
        ctx.beginPath();
        ctx.arc(hole.x, hole.y, hole.r, 0, Math.PI*2);
        ctx.fillStyle = '#111';
        ctx.fill();
        // Inner shadow of hole
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // 5. Drag Line (Power Indicator)
        if (isDragging) {
            let dx = dragStart.x - dragCurrent.x;
            let dy = dragStart.y - dragCurrent.y;
            
            ctx.beginPath();
            ctx.moveTo(ball.x, ball.y);
            // Cap visual length
            ctx.lineTo(ball.x + dx, ball.y + dy);
            
            // Color based on power
            let power = Math.sqrt(dx*dx + dy*dy);
            let pPct = Math.min(power / 150, 1);
            ctx.strokeStyle = `rgb(${255 * pPct}, ${255 * (1-pPct)}, 0)`;
            
            ctx.lineWidth = 4;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Arrow head
            ctx.beginPath();
            ctx.arc(ball.x + dx, ball.y + dy, 5, 0, Math.PI*2);
            ctx.fillStyle = ctx.strokeStyle;
            ctx.fill();
        }

        // 6. Ball (Sphere Look)
        // Shadow
        ctx.beginPath();
        ctx.ellipse(ball.x + 3, ball.y + 3, ball.r, ball.r * 0.8, 0, 0, Math.PI*2);
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fill();

        // Body
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        // Radial Gradient for 3D effect
        let bGrad = ctx.createRadialGradient(ball.x - 3, ball.y - 3, 2, ball.x, ball.y, ball.r);
        bGrad.addColorStop(0, '#fff');
        bGrad.addColorStop(0.3, '#ecf0f1');
        bGrad.addColorStop(1, '#bdc3c7');
        ctx.fillStyle = bGrad;
        ctx.fill();
        
        // Outline
        ctx.strokeStyle = '#95a5a6';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // --- Loop ---
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // Start Game
    loadLevel(0);
    loop();

</script>
</body>
</html>
