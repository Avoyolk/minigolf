<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mini Golf</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevents scrollbars */
            background-color: #2c3e50;
            font-family: sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            touch-action: none; /* Disables standard touch gestures like zoom */
        }
        h1 { font-size: 24px; margin: 10px 0; }
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
            padding: 0 10px; /* Safety padding for edges */
            box-sizing: border-box;
        }
        canvas {
            width: 100%; /* responsive width */
            height: auto; /* maintain aspect ratio */
            background-color: #4CAF50;
            border: 4px solid #4a3b2a;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            display: block;
        }
        .controls { margin-top: 10px; text-align: center; font-size: 14px; }
    </style>
</head>
<body>

    <h1>â›³ Pocket Golf</h1>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
    </div>
    
    <div class="controls">
        <p>Drag anywhere to putt!</p>
        <p id="status">Strokes: 0</p>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('status');

    // --- Variables ---
    let strokes = 0;
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let dragCurrentX = 0, dragCurrentY = 0;

    // --- Physics ---
    const FRICTION = 0.97;
    const POWER_SCALE = 0.20; 
    const MAX_POWER = 18;
    const STOP_THRESHOLD = 0.1;

    // --- Objects ---
    const ball = { x: 100, y: 250, radius: 10, vx: 0, vy: 0, color: 'white' };
    const hole = { x: 700, y: 250, radius: 14, color: '#1a1a1a' };
    const walls = [
        { x: 300, y: 0, w: 20, h: 350 },
        { x: 500, y: 150, w: 20, h: 350 },
        { x: 380, y: 200, w: 60, h: 60 }
    ];

    // --- Input Handling ---
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        // Calculate scale factor (CSS size vs Internal size)
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        let clientX = e.clientX;
        let clientY = e.clientY;

        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        }

        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    function startInput(e) {
        if (Math.abs(ball.vx) < STOP_THRESHOLD && Math.abs(ball.vy) < STOP_THRESHOLD) {
            isDragging = true;
            const pos = getPos(e);
            dragStartX = pos.x;
            dragStartY = pos.y;
            dragCurrentX = dragStartX;
            dragCurrentY = dragStartY;
        }
    }

    function moveInput(e) {
        if (isDragging) {
            // Prevent scrolling on mobile
            if(e.cancelable) e.preventDefault(); 
            const pos = getPos(e);
            dragCurrentX = pos.x;
            dragCurrentY = pos.y;
        }
    }

    function endInput() {
        if (isDragging) {
            isDragging = false;
            let dx = dragStartX - dragCurrentX;
            let dy = dragStartY - dragCurrentY;
            
            ball.vx = dx * POWER_SCALE;
            ball.vy = dy * POWER_SCALE;

            let speed = Math.sqrt(ball.vx**2 + ball.vy**2);
            if (speed > MAX_POWER) {
                let ratio = MAX_POWER / speed;
                ball.vx *= ratio;
                ball.vy *= ratio;
            }
            strokes++;
            statusText.innerText = `Strokes: ${strokes}`;
        }
    }

    // Event Listeners
    canvas.addEventListener('mousedown', startInput);
    canvas.addEventListener('mousemove', moveInput);
    window.addEventListener('mouseup', endInput);
    
    canvas.addEventListener('touchstart', startInput, {passive: false});
    canvas.addEventListener('touchmove', moveInput, {passive: false});
    window.addEventListener('touchend', endInput);

    // --- Game Loop ---
    function update() {
        ball.x += ball.vx;
        ball.y += ball.vy;
        ball.vx *= FRICTION;
        ball.vy *= FRICTION;

        if (Math.abs(ball.vx) < STOP_THRESHOLD) ball.vx = 0;
        if (Math.abs(ball.vy) < STOP_THRESHOLD) ball.vy = 0;

        // Boundaries
        if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -1; }
        if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -1; }
        if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -1; }
        if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -1; }

        // Walls
        walls.forEach(w => {
            let closestX = Math.max(w.x, Math.min(ball.x, w.x + w.w));
            let closestY = Math.max(w.y, Math.min(ball.y, w.y + w.h));
            let dx = ball.x - closestX;
            let dy = ball.y - closestY;
            let dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < ball.radius) {
                let penX = ball.radius - Math.abs(dx);
                let penY = ball.radius - Math.abs(dy);
                if (Math.abs(dx) > Math.abs(dy)) {
                    ball.vx *= -1;
                    ball.x += (ball.x < w.x + w.w/2) ? -penX : penX;
                } else {
                    ball.vy *= -1;
                    ball.y += (ball.y < w.y + w.h/2) ? -penY : penY;
                }
            }
        });

        // Win
        let d = Math.sqrt((ball.x - hole.x)**2 + (ball.y - hole.y)**2);
        if (d < hole.radius && Math.sqrt(ball.vx**2 + ball.vy**2) < 5) {
            alert(`Hole in ${strokes}!`);
            ball.x = 100; ball.y = 250; ball.vx = 0; ball.vy = 0;
            strokes = 0; statusText.innerText = "Strokes: 0";
        }
    }

    function draw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        
        // Hole
        ctx.fillStyle = hole.color; ctx.beginPath(); ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI*2); ctx.fill();

        // Walls
        ctx.fillStyle = "#8d6e63"; ctx.strokeStyle = "#5d4037"; ctx.lineWidth = 2;
        walls.forEach(w => { ctx.fillRect(w.x, w.y, w.w, w.h); ctx.strokeRect(w.x, w.y, w.w, w.h); });

        // Drag Line
        if (isDragging) {
            ctx.beginPath();
            ctx.moveTo(ball.x, ball.y);
            ctx.lineTo(ball.x + (dragStartX - dragCurrentX), ball.y + (dragStartY - dragCurrentY));
            ctx.strokeStyle = "rgba(255,255,255,0.6)"; ctx.lineWidth = 4; ctx.setLineDash([10, 10]);
            ctx.stroke(); ctx.setLineDash([]);
        }

        // Ball
        ctx.fillStyle = ball.color; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.stroke();
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }
    loop();
</script>
</body>
</html>
