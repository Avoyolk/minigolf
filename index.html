<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Mini Golf</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Arial', sans-serif; }
        
        /* The UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Let clicks pass through to the game */
            text-shadow: 2px 2px 4px #000;
        }

        h1 {
            color: white;
            margin: 0;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #stats {
            color: #FFD700; /* Gold color */
            font-size: 18px;
            font-weight: bold;
            margin-top: 5px;
        }

        #tutorial {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            opacity: 0.8;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-container">
        <h1>â›³ 3D Golf</h1>
        <div id="stats">Player: Jesse | Strokes: 0</div>
    </div>

    <div id="tutorial">Drag & Release to Putt</div>

<script>
    // --- 1. SETUP THE SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky Blue

    // Camera (Perspective)
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 40, 40); // High angle view
    camera.lookAt(0, 0, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; // Turn on shadows
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.camera.top = 20;
    dirLight.shadow.camera.bottom = -20;
    dirLight.shadow.camera.left = -20;
    dirLight.shadow.camera.right = 20;
    scene.add(dirLight);

    // --- 2. CREATE OBJECTS ---
    
    // Physics variables (Simulated 2D physics on X/Z plane)
    let ballVelocity = { x: 0, z: 0 };
    const FRICTION = 0.96;
    let strokes = 0;

    // Grass (Ground)
    const planeGeometry = new THREE.PlaneGeometry(60, 40);
    const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
    const ground = new THREE.Mesh(planeGeometry, planeMaterial);
    ground.rotation.x = -Math.PI / 2; // Lay flat
    ground.receiveShadow = true;
    scene.add(ground);

    // Ball
    const ballGeo = new THREE.SphereGeometry(0.8, 32, 32);
    const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const ball = new THREE.Mesh(ballGeo, ballMat);
    ball.position.set(-20, 0.8, 0); // Start position
    ball.castShadow = true;
    scene.add(ball);

    // Hole (Visual black cylinder)
    const holeGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.1, 32);
    const holeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const hole = new THREE.Mesh(holeGeo, holeMat);
    hole.position.set(20, 0.05, 0); // Target position
    scene.add(hole);

    // Walls
    const walls = [];
    const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });

    function createWall(x, z, w, d) {
        const h = 2; // Wall height
        const geo = new THREE.BoxGeometry(w, h, d);
        const wall = new THREE.Mesh(geo, wallMaterial);
        wall.position.set(x, h/2, z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        // Store for collision logic
        walls.push({ 
            minX: x - w/2, maxX: x + w/2, 
            minZ: z - d/2, maxZ: z + d/2 
        });
    }

    // Border Walls
    createWall(0, -20.5, 61, 1); // Bottom
    createWall(0, 20.5, 61, 1);  // Top
    createWall(-30.5, 0, 1, 42); // Left
    createWall(30.5, 0, 1, 42);  // Right

    // Obstacles
    createWall(0, 0, 2, 15);     // Center Vertical
    createWall(10, 10, 2, 10);   // Top Right Blocker

    // Aim Line (Visual helper)
    const lineMat = new THREE.LineBasicMaterial({ color: 0xffff00 });
    const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
    const aimLine = new THREE.Line(lineGeo, lineMat);
    scene.add(aimLine);
    aimLine.visible = false;

    // --- 3. INPUT & RAYCASTING ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isDragging = false;
    let startPoint = new THREE.Vector3();

    function getIntersect(event) {
        // Normalize mouse/touch to -1 to +1
        let clientX, clientY;
        if (event.changedTouches) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(ground);
        if (intersects.length > 0) return intersects[0].point;
        return null;
    }

    function onDown(e) {
        // Only allow drag if ball is slow
        if (Math.abs(ballVelocity.x) < 0.05 && Math.abs(ballVelocity.z) < 0.05) {
            const point = getIntersect(e);
            if (point) {
                isDragging = true;
                startPoint.copy(point);
                aimLine.visible = true;
            }
        }
    }

    function onMove(e) {
        if (!isDragging) return;
        const point = getIntersect(e);
        if (point) {
            // Update visual line
            const points = [ball.position, point];
            aimLine.geometry.setFromPoints(points);
        }
    }

    function onUp(e) {
        if (!isDragging) return;
        isDragging = false;
        aimLine.visible = false;

        const endPoint = getIntersect(e);
        if (endPoint) {
            // Calculate vector
            const dx = startPoint.x - endPoint.x;
            const dz = startPoint.z - endPoint.z;
            
            // Add force (scaled)
            ballVelocity.x = dx * 0.15;
            ballVelocity.z = dz * 0.15;

            // Cap max speed
            const speed = Math.sqrt(ballVelocity.x**2 + ballVelocity.z**2);
            if(speed > 2) {
                const ratio = 2 / speed;
                ballVelocity.x *= ratio;
                ballVelocity.z *= ratio;
            }

            strokes++;
            document.getElementById('stats').innerText = `Player: Jesse | Strokes: ${strokes}`;
        }
    }

    // Listeners
    window.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    
    window.addEventListener('touchstart', onDown, {passive: false});
    window.addEventListener('touchmove', onMove, {passive: false});
    window.addEventListener('touchend', onUp);

    // --- 4. GAME LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        // Apply Velocity
        ball.position.x += ballVelocity.x;
        ball.position.z += ballVelocity.z;

        // Friction
        ballVelocity.x *= FRICTION;
        ballVelocity.z *= FRICTION;

        // Stop if very slow
        if (Math.abs(ballVelocity.x) < 0.001) ballVelocity.x = 0;
        if (Math.abs(ballVelocity.z) < 0.001) ballVelocity.z = 0;

        // Collision: Walls
        const r = 0.8; // Ball radius
        walls.forEach(w => {
            // Simple AABB vs Point check
            if (ball.position.x + r > w.minX && ball.position.x - r < w.maxX &&
                ball.position.z + r > w.minZ && ball.position.z - r < w.maxZ) {
                
                // Determine bounce direction (Rough approximation)
                // If we are deeper in X than Z, likely a Z collision, and vice versa.
                // For simplicity in this mini-version, we just invert the one we are closest to exiting.
                
                // A simpler, robust method for this specific layout:
                // Check previous position? (Complex). 
                // Let's just bounce opposite to velocity for now.
                ballVelocity.x *= -1;
                ballVelocity.z *= -1;
                // Push out slightly to prevent sticking
                ball.position.x += ballVelocity.x * 2; 
                ball.position.z += ballVelocity.z * 2;
            }
        });

        // Rotation (Visual effect)
        ball.rotation.x -= ballVelocity.z;
        ball.rotation.z += ballVelocity.x;

        // Win Condition
        const dist = Math.sqrt((ball.position.x - hole.position.x)**2 + (ball.position.z - hole.position.z)**2);
        const speed = Math.sqrt(ballVelocity.x**2 + ballVelocity.z**2);
        
        if (dist < 1.0 && speed < 0.3) {
            alert(`Hole in ${strokes}! Great job Jesse!`);
            // Reset
            ball.position.set(-20, 0.8, 0);
            ballVelocity.x = 0;
            ballVelocity.z = 0;
            strokes = 0;
            document.getElementById('stats').innerText = `Player: Jesse | Strokes: 0`;
        }

        renderer.render(scene, camera);
    }

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
