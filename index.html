<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jesse's Golf: Centurion 100</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            touch-action: none;
        }

        #game-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #222;
            padding: 10px;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 2/3;
            border-radius: 12px;
            box-shadow: 0 0 25px rgba(0,0,0,0.5);
            border: 6px solid #5d4037;
            background: #4cd137;
            display: block;
        }

        #dashboard {
            height: 90px;
            background: #2c3e50;
            border-top: 4px solid #f1c40f;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            color: white;
            z-index: 10;
        }

        .info-panel { display: flex; flex-direction: column; }
        .player-name { font-size: 18px; font-weight: bold; color: #f1c40f; }
        .level-info { font-size: 14px; color: #bdc3c7; }

        .controls { display: flex; gap: 10px; }
        .btn {
            background: #ecf0f1; border: none; border-radius: 10px;
            padding: 8px 12px; font-size: 20px; cursor: pointer;
            box-shadow: 0 4px #bdc3c7; transition: transform 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; }
        .rainbow-btn { background: linear-gradient(45deg, red, yellow, lime, cyan, blue, magenta); color: white; }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 50;
            text-align: center;
        }
        #overlay h1 { font-size: 36px; margin-bottom: 10px; color: #f1c40f; }
        #overlay button {
            background: #2ecc71; color: white; font-size: 20px; padding: 15px 30px;
            border: none; border-radius: 50px; cursor: pointer; margin-top: 20px;
        }
        .water-msg { color: #3498db; font-size: 24px; font-weight: bold; display: none; position: absolute; top: 40%; width: 100%; text-align: center; text-shadow: 0 2px 4px rgba(0,0,0,0.5); pointer-events: none;}
    </style>
</head>
<body>

    <div id="game-area">
        <canvas id="gameCanvas" width="600" height="900"></canvas>
        <div id="waterMsg" class="water-msg">SPLASH! +1 STROKE</div>
    </div>

    <div id="dashboard">
        <div class="info-panel">
            <div class="player-name">üë§ JESSE</div>
            <div class="level-info" id="level-display">Level 1</div>
        </div>
        <div class="controls">
            <button class="btn rainbow-btn" id="rainbowToggle">üåà</button>
            <button class="btn" id="skipBtn">‚è≠Ô∏è</button> <button class="btn" id="resetBtn">üîÑ</button>
        </div>
    </div>

    <div id="overlay">
        <h1 id="overlay-title">HOLE IN ONE!</h1>
        <p id="overlay-sub">Strokes: 0</p>
        <button id="nextBtn">NEXT LEVEL ‚ñ∂</button>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI
    const levelDisplay = document.getElementById('level-display');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlaySub = document.getElementById('overlay-sub');
    const nextBtn = document.getElementById('nextBtn');
    const rainbowBtn = document.getElementById('rainbowToggle');
    const resetBtn = document.getElementById('resetBtn');
    const skipBtn = document.getElementById('skipBtn');
    const waterMsg = document.getElementById('waterMsg');

    // --- Assets ---
    let grassPattern;
    try {
        const c = document.createElement('canvas'); c.width = 64; c.height = 64;
        const x = c.getContext('2d');
        x.fillStyle = '#27ae60'; x.fillRect(0,0,64,64);
        x.fillStyle = '#2ecc71'; x.globalAlpha = 0.15;
        x.beginPath(); x.arc(10,10,30,0,Math.PI*2); x.fill();
        x.beginPath(); x.arc(50,50,20,0,Math.PI*2); x.fill();
        grassPattern = ctx.createPattern(c, 'repeat');
    } catch(e) { grassPattern = '#27ae60'; }

    // --- State ---
    let currentLevelIdx = 0;
    let strokes = 0;
    let gameState = 'PLAYING'; // PLAYING, WON, DROWNING
    let isRainbow = false; 
    let rainbowHue = 0;

    // Physics
    let isDragging = false;
    let dragStart = {x:0, y:0};
    let dragCurrent = {x:0, y:0};
    const FRICTION = 0.97;
    const POWER_SCALE = 0.22;
    const MAX_POWER = 35;

    // Objects
    let ball = { x: 300, y: 800, r: 16, vx: 0, vy: 0 }; 
    let hole = { x: 300, y: 100, r: 24 };
    let walls = [];
    let chickens = [];
    let eggs = [];
    let ponds = [];
    let blocks67 = []; // The special "67" blocks

    // --- LEVEL GENERATOR ---
    const levels = [];
    
    // Helper to add manual levels
    function addLevel(bX, bY, hX, hY, wallData, chickenData=[], pondData=[], b67Data=[]) {
        levels.push({ 
            ball: {x: bX, y: bY}, 
            hole: {x: hX, y: hY}, 
            walls: wallData, 
            chickens: chickenData,
            ponds: pondData,
            blocks67: b67Data 
        });
    }

    // 1. Straight
    addLevel(300, 800, 300, 150, [{x: 100, y: 400, w: 20, h: 200}, {x: 480, y: 400, w: 20, h: 200}]);
    
    // 2. The Pond Intro
    addLevel(300, 800, 300, 100, [], [], [{x: 300, y: 450, r: 60}]);

    // 3. Chicken & Water
    addLevel(300, 800, 300, 100, [], [{x: 300, y: 300, r: 40}], [{x: 150, y: 500, r: 50}, {x: 450, y: 500, r: 50}]);

    // 4. The Gate
    addLevel(300, 800, 300, 100, [{x: 0, y: 400, w: 240, h: 20}, {x: 360, y: 400, w: 240, h: 20}]);
    
    // 5. THE "67" BLOCK INTRO
    addLevel(300, 800, 300, 100, [], [], [], [{x: 300, y: 450, s: 80}]);

    // 6. Zig Zag Ponds
    addLevel(100, 800, 500, 100, [], [], [{x: 200, y: 600, r: 40}, {x: 400, y: 400, r: 40}, {x: 200, y: 200, r: 40}]);

    // 7. Chicken Army
    addLevel(300, 800, 300, 100, [], [{x: 150, y: 300, r: 35}, {x: 450, y: 300, r: 35}, {x: 300, y: 500, r: 35}]);

    // 8. Narrow Bridge
    addLevel(300, 850, 300, 50, [], [], [{x: 150, y: 450, r: 140}, {x: 450, y: 450, r: 140}]);

    // --- PROCEDURAL GENERATION (Levels 9 - 100) ---
    for(let i=9; i<100; i++) {
        let levelNum = i+1;
        
        // Setup positions
        let hX = 100 + Math.random() * 400;
        let hY = 50 + Math.random() * 150;
        let bX = 300;
        let bY = 800;

        let w = [];
        let c = [];
        let p = [];
        let b67 = [];

        // Special Level 67
        if (levelNum === 67) {
            bX = 300; bY = 800; hX = 300; hY = 100;
            // A field of 67 blocks
            b67.push({x: 200, y: 400, s: 60});
            b67.push({x: 400, y: 400, s: 60});
            b67.push({x: 300, y: 600, s: 60});
        } else {
            // Random Walls (1 to 3)
            let numWalls = 1 + Math.floor(Math.random()*3);
            for(let k=0; k<numWalls; k++) {
                if(Math.random()>0.5) {
                    // Horizontal
                    w.push({x: Math.random()*400, y: 300+Math.random()*400, w: 150, h: 20});
                } else {
                    // Vertical
                    w.push({x: Math.random()*500, y: 200+Math.random()*400, w: 20, h: 150});
                }
            }

            // Random Ponds (0 to 3)
            let numPonds = Math.floor(Math.random()*3);
            for(let k=0; k<numPonds; k++) {
                p.push({x: 100+Math.random()*400, y: 300+Math.random()*400, r: 30+Math.random()*30});
            }

            // Random Chickens (0 to 2)
            let numChickens = Math.floor(Math.random()*3);
            for(let k=0; k<numChickens; k++) {
                c.push({x: 100+Math.random()*400, y: 300+Math.random()*300, r: 30});
            }
        }

        addLevel(bX, bY, hX, hY, w, c, p, b67);
    }

    // --- Logic ---
    function loadLevel(idx) {
        if(idx >= levels.length) {
            overlayTitle.innerText = "üíØ CENTURION!";
            overlaySub.innerText = "You beat 100 levels!";
            nextBtn.innerText = "RESTART";
            nextBtn.onclick = () => { currentLevelIdx=0; loadLevel(0); };
            overlay.style.display = 'flex';
            return;
        }
        
        const d = levels[idx];
        ball.x = d.ball.x; ball.y = d.ball.y;
        ball.vx = 0; ball.vy = 0;
        hole.x = d.hole.x; hole.y = d.hole.y;
        walls = d.walls || [];
        chickens = (d.chickens || []).map(c => ({...c, hasLaidEgg: false}));
        ponds = d.ponds || [];
        blocks67 = d.blocks67 || [];
        eggs = [];
        
        strokes = 0;
        gameState = 'PLAYING';
        levelDisplay.innerText = `LEVEL ${idx+1} / 100`;
        overlay.style.display = 'none';
        waterMsg.style.display = 'none';
    }

    rainbowBtn.onclick = () => { isRainbow = !isRainbow; rainbowBtn.innerText = isRainbow ? "‚ö™" : "üåà"; };
    resetBtn.onclick = () => { 
        // Reset to start of level
        const d = levels[currentLevelIdx];
        ball.x = d.ball.x; ball.y = d.ball.y; 
        ball.vx=0; ball.vy=0; 
        gameState = 'PLAYING';
        waterMsg.style.display = 'none';
        strokes++; // Penalty for manual reset
    };
    skipBtn.onclick = () => {
        currentLevelIdx++;
        loadLevel(currentLevelIdx);
    };

    function getPos(e) {
        const r = canvas.getBoundingClientRect();
        const sx = canvas.width / r.width;
        const sy = canvas.height / r.height;
        let cx = e.clientX, cy = e.clientY;
        if(e.touches && e.touches.length) { cx=e.touches[0].clientX; cy=e.touches[0].clientY; }
        return { x: (cx-r.left)*sx, y: (cy-r.top)*sy };
    }

    function start(e) {
        if(gameState !== 'PLAYING') return;
        if(Math.abs(ball.vx)<0.1 && Math.abs(ball.vy)<0.1) {
            isDragging=true; dragStart = getPos(e); dragCurrent = dragStart;
        }
    }
    function move(e) {
        if(isDragging) { if(e.cancelable) e.preventDefault(); dragCurrent = getPos(e); }
    }
    function end() {
        if(isDragging) {
            isDragging=false;
            let dx = dragStart.x - dragCurrent.x;
            let dy = dragStart.y - dragCurrent.y;
            ball.vx = dx * POWER_SCALE; ball.vy = dy * POWER_SCALE;
            let s = Math.sqrt(ball.vx**2 + ball.vy**2);
            if(s > MAX_POWER) { ball.vx *= (MAX_POWER/s); ball.vy *= (MAX_POWER/s); }
            if(s > 1) strokes++;
        }
    }

    canvas.addEventListener('mousedown', start);
    window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
    canvas.addEventListener('touchstart', start, {passive:false});
    window.addEventListener('touchmove', move, {passive:false}); window.addEventListener('touchend', end);

    function splash() {
        gameState = 'DROWNING';
        ball.vx = 0; ball.vy = 0;
        waterMsg.style.display = 'block';
        setTimeout(() => {
            const d = levels[currentLevelIdx];
            ball.x = d.ball.x; ball.y = d.ball.y;
            strokes++; // Penalty
            waterMsg.style.display = 'none';
            gameState = 'PLAYING';
        }, 1500);
    }

    function update() {
        if(gameState !== 'PLAYING') return;

        ball.x += ball.vx; ball.y += ball.vy;
        ball.vx *= FRICTION; ball.vy *= FRICTION;
        if(Math.abs(ball.vx)<0.1) ball.vx=0; if(Math.abs(ball.vy)<0.1) ball.vy=0;

        // Eggs Move
        eggs.forEach(egg => {
            egg.x += egg.vx; egg.y += egg.vy;
            egg.vx *= 0.9; egg.vy *= 0.9;
        });

        // Bounds
        if(ball.x<ball.r) { ball.x=ball.r; ball.vx*=-0.8; }
        if(ball.x>canvas.width-ball.r) { ball.x=canvas.width-ball.r; ball.vx*=-0.8; }
        if(ball.y<ball.r) { ball.y=ball.r; ball.vy*=-0.8; }
        if(ball.y>canvas.height-ball.r) { ball.y=canvas.height-ball.r; ball.vy*=-0.8; }

        // Ponds (Water Hazard)
        ponds.forEach(p => {
            let dx = ball.x - p.x;
            let dy = ball.y - p.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            // If ball center is well inside the pond
            if(dist < p.r - 5) {
                splash();
            }
        });

        // Walls
        walls.forEach(w => {
            // Simple AABB vs Circle logic
            let cx = Math.max(w.x, Math.min(ball.x, w.x+w.w));
            let cy = Math.max(w.y, Math.min(ball.y, w.y+w.h));
            let dx = ball.x - cx, dy = ball.y - cy;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < ball.r) {
                if(Math.abs(dx) > Math.abs(dy)) ball.vx *= -1; else ball.vy *= -1;
                let pen = ball.r - dist;
                let angle = Math.atan2(dy, dx);
                ball.x += Math.cos(angle)*pen; ball.y += Math.sin(angle)*pen;
            }
        });

        // 67 Blocks (Square obstacles)
        blocks67.forEach(b => {
            let s = b.s; // size (width/height)
            let cx = Math.max(b.x - s/2, Math.min(ball.x, b.x + s/2));
            let cy = Math.max(b.y - s/2, Math.min(ball.y, b.y + s/2));
            let dx = ball.x - cx, dy = ball.y - cy;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < ball.r) {
                 if(Math.abs(dx) > Math.abs(dy)) ball.vx *= -1; else ball.vy *= -1;
                 let pen = ball.r - dist;
                 let angle = Math.atan2(dy, dx);
                 ball.x += Math.cos(angle)*pen; ball.y += Math.sin(angle)*pen;
            }
        });

        // Chickens
        chickens.forEach(c => {
            let dx = ball.x - c.x, dy = ball.y - c.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let minDist = c.r + ball.r;
            if(dist < minDist) {
                let angle = Math.atan2(dy, dx);
                let tx = c.x + Math.cos(angle) * minDist;
                let ty = c.y + Math.sin(angle) * minDist;
                let ax = (tx - ball.x) * 0.1, ay = (ty - ball.y) * 0.1;
                ball.vx -= ax; ball.vy -= ay; ball.vx *= -0.9; ball.vy *= -0.9;
                ball.x = tx; ball.y = ty;
                if(!c.hasLaidEgg) {
                    c.hasLaidEgg = true;
                    eggs.push({ x: c.x, y: c.y, r: 12, vx: (Math.random()-0.5)*5, vy: 5 });
                }
            }
        });

        // Eggs
        eggs.forEach(egg => {
            let dx = ball.x - egg.x, dy = ball.y - egg.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < egg.r + ball.r) {
                let angle = Math.atan2(dy, dx);
                let tx = egg.x + Math.cos(angle) * (egg.r + ball.r);
                let ty = egg.y + Math.sin(angle) * (egg.r + ball.r);
                ball.vx *= -0.9; ball.vy *= -0.9;
                ball.x = tx; ball.y = ty;
                egg.vx += ball.vx*0.2; egg.vy += ball.vy*0.2;
            }
        });

        // Win
        let dh = Math.sqrt((ball.x-hole.x)**2 + (ball.y-hole.y)**2);
        if(dh < hole.r && Math.abs(ball.vx) < 8 && Math.abs(ball.vy) < 8) {
            gameState = 'WON';
            setTimeout(() => {
                overlayTitle.innerText = "HOLE IN ONE!";
                overlaySub.innerText = `Strokes: ${strokes}`;
                nextBtn.onclick = () => { currentLevelIdx++; loadLevel(currentLevelIdx); };
                overlay.style.display = 'flex';
            }, 100);
        }
    }

    function draw() {
        // Background
        ctx.fillStyle = grassPattern;
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // Ponds
        ponds.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
            ctx.fillStyle = '#3498db'; ctx.fill();
            ctx.strokeStyle = '#85c1e9'; ctx.lineWidth = 4; ctx.stroke();
            // Water glint
            ctx.beginPath(); ctx.arc(p.x - p.r/3, p.y - p.r/3, p.r/5, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fill();
        });

        // Hole
        ctx.beginPath(); ctx.arc(hole.x, hole.y, hole.r, 0, Math.PI*2);
        ctx.fillStyle = '#111'; ctx.fill(); 
        ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=4; ctx.stroke();

        // Walls
        ctx.fillStyle = '#8d6e63';
        walls.forEach(w => {
            ctx.fillRect(w.x, w.y, w.w, w.h);
            ctx.strokeStyle='#5d4037'; ctx.lineWidth=3; ctx.strokeRect(w.x,w.y,w.w,w.h);
            ctx.fillStyle='#3e2723';
            ctx.beginPath(); ctx.arc(w.x+5,w.y+5,2,0,Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(w.x+w.w-5,w.y+w.h-5,2,0,Math.PI*2); ctx.fill();
            ctx.fillStyle='#8d6e63';
        });

        // 67 Blocks
        blocks67.forEach(b => {
            let s = b.s;
            let x = b.x - s/2;
            let y = b.y - s/2;
            // Draw Block
            ctx.fillStyle = '#7f8c8d'; // Concrete
            ctx.fillRect(x, y, s, s);
            ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 4;
            ctx.strokeRect(x, y, s, s);
            
            // Draw Text "67"
            ctx.fillStyle = '#f1c40f';
            ctx.font = `bold ${s/2}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("67", b.x, b.y);
        });

        // Entities
        eggs.forEach(egg => {
            ctx.save(); ctx.translate(egg.x, egg.y); ctx.scale(0.8, 1);
            ctx.beginPath(); ctx.arc(0, 0, egg.r, 0, Math.PI*2);
            ctx.fillStyle = '#ecf0f1'; ctx.fill();
            ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 2; ctx.stroke();
            ctx.restore();
        });

        chickens.forEach(c => {
            let x=c.x, y=c.y, r=c.r;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
            ctx.fillStyle = '#fff'; ctx.fill(); ctx.strokeStyle = '#ccc'; ctx.lineWidth=2; ctx.stroke();
            ctx.save(); ctx.translate(x, y - r/2); ctx.rotate(-0.2);
            ctx.beginPath(); ctx.arc(0, -5, r*0.6, 0.5, 2.6);
            ctx.bezierCurveTo(-r*0.8, -r*0.5, r*0.8, -r*0.5, r*0.3, 2);
            ctx.fillStyle = '#f1c40f'; ctx.fill(); ctx.lineWidth = 1; ctx.strokeStyle = '#d35400'; ctx.stroke();
            ctx.beginPath(); ctx.arc(-5, -5, 2, 0, Math.PI*2); ctx.fillStyle='black'; ctx.fill();
            ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(-18, 4); ctx.lineTo(-10, 8); ctx.fillStyle = '#e67e22'; ctx.fill();
            ctx.restore();
        });

        // Drag Line
        if(isDragging) {
            let dx = dragStart.x - dragCurrent.x;
            let dy = dragStart.y - dragCurrent.y;
            ctx.beginPath(); ctx.moveTo(ball.x, ball.y); ctx.lineTo(ball.x+dx, ball.y+dy);
            ctx.strokeStyle = 'white'; ctx.lineWidth=5; ctx.setLineDash([10,10]); ctx.stroke(); ctx.setLineDash([]);
        }

        // BALL
        if(gameState !== 'DROWNING') {
            ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
            if(isRainbow) {
                rainbowHue = (rainbowHue + 4) % 360;
                ctx.fillStyle = `hsl(${rainbowHue}, 100%, 50%)`;
            } else {
                let g = ctx.createRadialGradient(ball.x-5, ball.y-5, 2, ball.x, ball.y, ball.r);
                g.addColorStop(0, 'white'); g.addColorStop(1, '#bdc3c7');
                ctx.fillStyle = g;
            }
            ctx.fill();
            ctx.strokeStyle='#2c3e50'; ctx.lineWidth=3; ctx.stroke();
        }
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }
    loadLevel(0);
    loop();
</script>
</body>
</html>
